[[목차]]

http://oldcomputers.net/pics/ibm5100.jpg

== 개요 ==
1975년 6월 [[IBM]]에서 개발/출시한 휴대용 [[컴퓨터]]. 덤으로 역사상 최초의 휴대용 컴퓨터다. 출시 가격은 램 사양, 탑재 프로그램에 따라 달랐지만 최저 8,975 달러[* 16kb 램 + APL인 최저 패키지]부터 최대 19,975달러[* 64kb 램 + 베이직 + APL을 포함한 풀 패키지]까지 사양의 선택이 가능했다.

사양은 IBM PALM 1.9Mhz 프로세서, 16~64KB 램, 32~64KB 롬에 키보드가 본체에 붙어있는 형태였다. 무게는 '''24kg'''. 이따위 것이 왜 휴대용 컴퓨터였냐면, '''당시 컴퓨터 치고는''' 작았기 때문이다.[* 동시대에 "미니 컴퓨터"로 불리면서 업계에서 한가닥 했던 PDP-11의 크기가 [http://www.youtube.com/watch?v=iIsZVqhaneo 이정도]였으니 당연한것인지도 모른다.] 거기다가 키보드가 본체와 일체화되어있는 형태고 5인치 크기의 한화면에 64글자(16줄) 표시가능한 [[CRT]] 디스플레이를 달고 있었으며 테이프 드라이브, 프로세서 등 기본적으로 컴퓨터의 필요충분조건은 만족하고 있었다. 외부출력도 물론 지원했으며 보통 [[텔레비전]] 화면을 썼다고 한다. 게다가 어댑터를 쓰면 데이터 통신기능까지 지원한다!!

즉, 당시 기준으로 혁신적인 컴퓨터였다. 60년대 비슷한 사양의 컴퓨터였던 IBM제 컴퓨터는 500kg 가까운 무게를 갖고 있었으며, 이후 비슷한 사양으로 코모도에서 코모도 PET 2002을 출시하기까지 2년이 걸렸다는걸 감안하면 대단한것. 비슷한 크기의 데스크탑 컴퓨터로 HP 9830이란 기종이 있었지만 CRT나 큰 용량의 ROM/RAM을 탑재하는것은 불가능했다.


문제는 내장 배터리가 없어서 어댑터 없이는 쓸 수가 없었고[* 이 말인 즉슨, '''즉 전기 안들어오는 곳에선 못쓴다'''] 램 업그레이드의 선택이 가능하긴 했지만, 그럴 경우 가격 차이가 많이 나(맨 위에 가격 참조) 결국 대중적으로 쓰이진 못했다.

[[Steins;Gate]]에서는 '''IBN 5100'''으로 패러디되어서 나오며, 작품 전체의 중요한 키워드로 작용한다.

[http://bbs2.ruliweb.daum.net/gaia/do/ruliweb/default/hobby/312/read?articleId=22235420&bbsId=G005&itemId=110&pageIndex=1 2014년 8월 5일, 국내에 실제로 샀다고 인증한 사람이 나타났다.]

그리고 [http://gigglehd.com/zbxe/11779520 사용 가능한 상태로 고쳤다고 한다.]

TV 방송에도 [http://m.news.naver.com/read.nhn?oid=056&aid=0010070509&sid1=105&mode=LSD 나왔다.]



=== [[존 티토]]와의 관계 ===
21세기의 예언가(?) [[존 티토]]는 IBM 5100을 찾으러 1975년으로 타임슬립을 했다는 주장을 했다. 이유는 2038년의 미래의 인터넷망을 복구하기 위해 필요하다나 뭐라나... 하는 이유다. 정확히는 2038년에는 컴퓨터에 '[wiki:"2038년 문제" 유닉스 버그]'가 발생하는데, 이 버그를 막기 위해서는 IBM 5100의 특정한 내장함수가 필요하다는 것이다. 근데 2038년 기준으로 제대로 된 IBM 5100이 없었기 때문에 찾아오려고 했다는 것.--아니,그 미래에 공돌이 안갈고 뭐하냐--

물론 당시 사람들은 이게 무슨 헛소리냐고 넘겼는데, IBM 5100의 개발에 참여했던 한 기술자가 '''"사실이다. IBM 5100에는 매뉴얼에 없는 숨겨진 기능이 있다"''' 라고 대답해서 화제가 되기도 했다. 그 중 하나는 이 기종으로 APL이나 BASIC 이전의 IBM 독자 사양의 특수한 컴퓨터 언어를 [디버그]할 수 있다.[* 물론 디버그 항목에서도 볼수 있지만, 해당 언어에 대한 지식, 해당 프로세서의 기계어에 대한 지식, 혹은 어셈블리어 전반에 대한 지식중 하나만 있어도 인간이 수행할 수 있는 작업이긴 하다. 실제로 대굇수 [존 폰 노이만]은 뇌내에서 자체 디버깅까지 한(혹은 디버깅이 필요가 없는 완벽한) 코드를 기계어로 짤 수 있었다.~~참 쉽죠?~~ 다만 시간/노동/비용상의 비효율이 클 뿐.]
