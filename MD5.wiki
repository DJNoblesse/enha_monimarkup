>'RigVeda Wiki'를 MD5변환한 결과 : A2625540BD3D38019AD6C68CBD0C659D
Message-Digest algorithm 5

임의의 길이의 값을 입력받아서 128비트 길이의 [[wiki:"해쉬" 해시값]]을 출력하는 [[알고리즘]]이다. [[1991년]] 설계되었다.

MD5는 단방향 암호화이기 때문에 출력값에서 입력값을 복원하는 것은 할 수 없다. 같은 입력값이면 항상 같은 출력값이 나오고, 서로 다른 입력값에서 같은 출력값이 나올 확률은 극히 낮다(0은 아니며 발생할 수 있다.). 

흔히 [[wiki:"비밀번호" 패스워드]] 암호화에 많이 사용되는데, 패스워드를 MD5로 해쉬해서 나온 값을 저장해 두는 것이다. 이렇게 하면 운영자나, 데이터를 무단으로 뜯어본 자도 이 값만 봐서는 본래의 값 자체는 알 수 없게 된다. 비밀번호를 정확하게 입력했다면 같은 해쉬값이 튀어나오므로, 본래의 키라는 것을 확인할 수는 있는 것이다.

단방향 암호화이기 때문에 MD5 해시값에서 원래의 데이터를 찾아내는것은 불가능하며(원문을 해시 계산 과정에서 '''비트 단위로 [[개발살]]내버린다'''), [[크래커]]들은 "같은 MD5를 갖는 문자열", 즉 "충돌"(Collision)을 찾아내는데 주력한다. 어쨌든 MD5값이 같으면 같은 문자열이라고 판단하기 때문이며 이는 모든 단방향 암호화에 통용되는 기법이다[* 1234나 love 등의 간단한 숫자나 단어만 써서 암호를 만들지 말라는 이유는 여기서도 통용된다. 이런 간단한 암호는 해커들이 가지고 있는 해시값 사전에도 있을 확률이 거의 100%이기 때문이다.]. 

2004년에 [http://eprint.iacr.org/2004/199 높은 유사성을 보이는(하지만 엄연히 다른) 128바이트 파일 두 개의 해쉬 값 충돌이 발견되었다.] 이는 알고리즘 자체의 엄청난 결함이다. 논문에 따르면 IBM P690 머신에서 충돌을 생성하는데 한 시간밖에 걸리지 않았다고 한다.

2006년에는 [http://eprint.iacr.org/2006/105 더욱 빠른 알고리즘이 개발되어 논문에 따르면 노트북 한 대의 연산 능력 (Intel Pentium, 1.6 GHz)으로 1분 만에 충돌을 찾아낼 수 있다고 한다.] 그래서 보안이 중요시되는 해시 연산은 [[SHA]] 계열 해시 함수로 대체되고 있다.

심지어는 [[http://www.mscs.dal.ca/~selinger/md5collision/ 다른 결과가 나오는 프로그램이 같은 MD5 값을 가질 수도 있다. ]]

다만 고속 연산이 가능하고(정수 연산 및 비트시프트로 모든게 해결된다.) 임의로 변경된 패턴에 대해서는 충돌 가능성이 충분히 낮기 때문에, 현재는 주로 네트워크로 전송된 큰 파일의 무결성을 확인하는데 주로 사용된다. 보안용도로 쓸 때는 꼭 salt를 붙여서 쓰는게 안전하지만 다른 알고리즘을 권장한다.

특히, 앞에서 언급된 네트워크에서는 OSI 7계층 중 2계층에 속하게되는 장비인 Switch, 3계층에 속하게되는 Router는 장비간의 상호인증체계로 활용된다. (Cisco IOS 기준)

== 관련항목 ==
 * [[비밀번호]]
 * [[암호]]
 * [[해쉬]]
 * [[MD5 배틀]]
 * [[SHA]]
