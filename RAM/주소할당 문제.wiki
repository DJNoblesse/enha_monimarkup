[[목차]]
 * 상위 항목 : [[RAM]]
== 설명 ==
이 항목은 하드웨어적으로는 사용할 수 있는데도 불구하고 소프트웨어적으로 처리가 불가능해 생기는 메모리 용량 문제를 설명한다.
원리는 운영체제 커널에서 사용할 수 있는 주소가 한정적이라서 그 주소의 수를 넘어가는 메모리 용량을 쓸 수 없기 때문에 생긴다.

비유를 하자면 서울시의 전화번호 체계가 02-xxxx-xxxx이기 때문에 1억 회선을 초과하여(02-0000-0000부터 02-9999-9999까지) 부여하는 게 불가능한 것과 같은 이치.[* 이 부분은 이해를 돕기 위한 비유적 설명이지만 실제로는 교환기의 작동 원리상 저렇게 꽉 채워서 할당할 수는 없다.] 서울시 전화국 교환기에 전화를 1억대 이상 달아봤자 1억대에만 전화번호를 부여할 수 있으므로 나머지는 무용지물이 된다.

== 640KB 문제(기본 메모리 문제) ==
[[MS-DOS]]의 기본 메모리(Conventional Memory)와 그에 관련된 주소체계가 640kB로 제한되어 있어서 발생하는 문제. [[IBM PC]] 및 [[IBM PC XT]]에서 이용된 [[인텔]] 8088 [[CPU]]에서 주소 지정을 1MB[* 내부적으로 주소에 20비트를 이용하였으므로 2^20=1MB이다.]까지만 할 수 있기 때문에 이에 맞춰 사용자 영역으로 640kB, 하드웨어 영역인 UMB(Upper Memory Block)를 384kB를 할당하였기에 생긴 문제다.

[[IBM PC AT]]에서 이용하는 80286 CPU에서는 주소를 16MB(24비트)까지 이용할 수 있었고 80386 이후의 32비트 CPU에서는 4GB(32비트)까지 늘어났지만 기존 프로그램의 호환성 때문에 DOS에서는 뭘 쓰든지 여전히 640kB만 이용할 수 있었다. 요즘도 32비트 운영체제에서는 램 8GB, 16GB를 달아도 4GB밖에 인식이 안 되고 그 중 몇백메가를 못 쓰는 것처럼[* 서버용 운영체제에서는 지원하기도 하고 [[램 디스크]]를 써서 이용하는 방법도 있기는 하다. 자세한 것은 아래의 4GB 문제 참조.], 장착된 램이 16MB라도 기본적으로 640KB를 넘는 메모리는 못 썼다.

기본 메모리에 이것저것을 올리다보면 어쩔 수 없이 기본 메모리가 점점 소모되는데, 이런 상태에서 기본 메모리를 많이 소모하는 프로그램을 돌리려 하면 메모리가 부족하다는 메시지를 뱉으면서 실패하게 된다.

Himem.sys나 EMM386/QEMM386등의 [[EMS]]/XMS 등의 기술을 써서 PC에 장착된 메모리의 전부를 사용할 수는 있었으나, 프로그램의 기본적인 부분은 640kB영역에 남아있고 용량 많이 먹는 데이터 쪽을 EMS/XMS영역으로 넘긴다는 개념이라 결국 640kB영역을 확보하기 위해 사활을 걸어야 했다.

게다가 마우스, CD-ROM 드라이버나 백신 등 백그라운드에서 실행되는 메모리 상주 프로그램은 기본 메모리에 올라가 있어야 한다. 그나마 드라이버는 config.sys에서 DEVICEHIGH 명령어를 통해 하드웨어를 위해 예약된 공간인 UMB로 올릴 수 있었지만, 실행 파일로 제공되는 메모리 상주 응용프로그램은 이마저도 불가능했다. 이런 것이 하나에 많으면 30~150kB정도 먹는데, 게임 같은 경우 기본 메모리를 특히 왕창 처먹기 때문에 실행하기 전에 570~610kB의 메모리를 확보해두어야 했다.

따라서 어쩔수 없이 메모리 상주 프로그램을 최대한 줄여서 기본 메모리를 확보해줘야 한다. [[Mdir]]을 종료하는 것은 물론이고, CD롬 드라이버 같은 드라이버도 제거하는 등 필사적인 노력을 해야 한다. 도스 6.0 이후에는 LOADHIGH 또는 INSTALLHIGH 명령어를 이용해 UMB에 올리는 것이 가능해졌다.

기본 메모리 확보를 위해서 아예 Config.sys와 Autoexec.bat를 별도로 제작하고, 특정 게임 실행을 위한 부팅 디스크를 따로 만드는 경우도 있었다.

16KB를 제외하고 상주프로그램을 전부 XMS/UMB로 넘겨서 625kB로 만들어주는 QEMM386이라는 메모리 관리툴이 선풍적인 인기를 끌었으나 몇몇 게임과의 충돌문제가 있었으며[* 대표적으로 어스토니시아 스토리, 신검의전설2],결국 MS도 QEMM386만큼은 못하지만 자체적으로 640kB영역을 튜닝해주는 Memmaker.exe를 MS-DOS 6.0부터 삽입하기 이르른다.

그러나 DOS4GW모듈 등을 이용하여 자체적으로 메모리를 관리하며 이용하는 게임들도 많았고 이 게임들은 XMS/UMB영역이 없는 것을 전제로 구동되기 때문에 클린 부팅(DOS의 안전모드)도 많이 필요했다. 담당자의 예측부족 덕에 고생한 케이스...

UMB영역과 XMS영역도 문제가 없는 것은 아니라서, 프로그램마다 요구하는 UMB와 XMS의 양이 달랐다. 어떤 프로그램은 UMB를 많이 요구하기도 하고, 어떤 프로그램은 XMS를 많이 요구하기도 하고, 극단적인 경우에는 그때그때 마다 메모리 셋팅을 바꿔줘야 했다.

가장 간단히 해결할 수 있는 방법은 용도에 따라서 부팅 디스켓을 따로 만드는 것이다. CD롬용 드라이버 유무, 마우스 유무등에 따라 부팅 디스켓을 따로 준비해 두고 각 게임이 원하는 세팅으로 나눠두는 것. 심하면 files와 buffer의 설정도 따지는 게임이 있었으니 정확히 세팅을 하는것이 쾌적한 게임을 위한 최소의 준비였다.

하지만 부팅 디스켓을 써버리면 문제가 하나 있는데, OS를 디스크에 저장하기 때문에 뭔가 할 때마다 [[플로피디스크]]를 벅벅 소리내며 긁어댄다는 점이다.

좀 더 쿨한 방법은 Config.sys와 Autoexec.bat를 '멀티부팅'이 가능하도록 다시 짜는 것. 간단한 메뉴를 통해 원하는 설정을 이용할 수 있다. 하지만 이것도 도스 6.0 이후만 가능해서...

기본 메모리 확보하는 능력은 당시 컴퓨터 초보자와 중급자를 가르는 기준이었으며 각종 PC잡지의 단골 기사거리였다. 서점에는 10여종 이상 관련 서적이 나오기도 했다. 그리고 집에서 게임이 안 돌아간다고 학교 친구에게 메모리 잡아달라고 부탁하는 경우도 종종 있었다. 당시 [[동급생]] 같은 일본의 [[에로게]]를 즐기던 게이머들은 이게 뭔지도 모르면서 무의식중에 학습해버리는 위업을 이루어내기도(보통 디스켓에 동봉되는 매뉴얼 파일에 방법이 적혀있었다).

근데 이렇게 고생을 해도, 결국 게임하다가 다른 거 하려면 컴퓨터를 재부팅 해야 한다는건 변하지 않는다.(…) 그나마 도스 시절에는 부팅 시간이 짧았기에 망정이지... ~~그나마도 [[UEFI]]+[[SSD]]의 등장으로 부팅 시간을 10초대를 끊는 지금에 비해서 느린 편이다.~~

이 문제는 결국 1990년대 중반, [[Windows 95]]가 나오면서 서서히 사라지게 된다. 운영체제의 구조가 근본적으로 바뀌면서 기본 메모리 문제 자체가 사라진 것이다. 물론 윈도우 95에서도 도스용 프로그램을 돌리면 기본 메모리 문제가 있었지만, 도스용 프로그램들이 윈도우용으로 버전업되고 게임도 신작이 윈도우용으로 줄줄이 나오면서 서서히 사라지게 된다.

생각해보면 요즘은 진짜 컴퓨터 편하게 하는 거야.(…)[* 이 당시에는 열악한 상황 탓에 정말 하드웨어 성능을 극한까지 짜내고도 30프레임 게임이 고작이었다. 요즘 기준으로 구리다고 판단하는 건 무식을 자랑하는 짓이다.]

== 512MB 문제 ==
[[Windows 95]], [[Windows 98]], [[Windows Me]] 한정으로 32비트 OS임에도 512MB 이상의 메모리를 쓸 수 없게 되어 있으며, 이를 초과하는 메모리를 장착했을 경우 '''메모리 부족'''(????)이라는 오류를 내뱉는다. ~~[[이뭐병]]~~ 시스템 파일을 뜯어고쳐서 512MB로 메모리를 제한해야만 한다. 물론 당시는 램값이 컴퓨터 부품 중 제일 비쌌기 때문에 별 문제가 안 되긴 했지만. 위 윈도우가 주로 쓰일 당시에는 128MB는 커녕 64MB만 돼도 램 많다는 소리들을 수 있었다. 윈도우 Me 이후 2001년도쯤 128MB 탑재 컴퓨터가 보편화되기 시작했지만[* 윈도우 Me 때는 파워유저라 불리는 사람들 중 상위 클래스(...)는 512MB를 사용중이었긴 하지만... 대신 Me가 별로 쓰이지 않았고. 어차피 파워유저들은 윈도우2000으로 가지 윈도우Me/98을 깔아쓰는 사람이 없었기때문에 별 문제도 안 됐다.] 512MB 이상이 대중화됐을 때는 약 2003년도 이후로 이미 대세가 [[Windows XP]]로 넘어간 후였으므로 거의 문제가 되지 않았다. 한참 지나 램 업체간의 [[치킨 게임]]이 벌어지고 나서야 발견된 문제.

[[VirtualBox]]에서는 새 가상머신을 생성할 때 메모리 세팅을 기본으로 512MB로 잡는데, 이 문제 때문이다.

== 4GB 문제 ==
인텔의 32비트 CPU인 [[386|80386]]에서는 메모리 주소에 32비트를 이용하였고, 메모리는 바이트 단위로 주소를 매기므로 최대 4GB까지 주소를 부여할 수 있다는 말이 된다. 따라서 32비트용 프로그램은 4GB까지 이용할 수 있었다. 이는 80286에 비하면 256배 증가한 것이어서 꽤 오랫동안 버틸 수 있었으나 기술의 발전은 결국 4GB도 부족한 용량으로 만들고 말았다.

하지만 32비트 CPU와 [[운영체제]]는 기존과 호환성을 유지해야 하므로 근본적인 구조를 바꿀 수 없었고[* 최초의 32비트 윈도우는 펜티엄 프로보다 먼저 나왔다. 당연히 이전에 나온 프로그램이나 CPU는 PAE를 지원하지 않는다.], 이로 인해 4GB의 제한은 계속되었다. 게다가 주소의 일부는 하드웨어 영역으로 할당되어 있고 나머지에서 다시 커널 공간이 빠지기 때문에 실제로 쓸 수 있는 양은 더 작아 약 3GB정도밖에 쓸 수 없다. 하드웨어상에서 메모리 주소를 우선적으로 부여받는 장치들과, 운영체제의 종류와 시스템 영역에 할당되는 용량이 개개 컴퓨터마다 다르므로 딱 얼마만큼 쓸 수 있다고 잘라 말할 수는 없지만 대략 2GB~3.75GB 정도 쓸 수 있다고 보면 된다. 운영체제는 커널 공간과 사용자 공간을 엄격히 구분해서 동작하는데 커널 공간에 얼마를 주냐에 따라 사용자 공간에 줄 수 있는 주소 범위가 정해진다. 실제 꼽혀 있는 RAM용량을 소프트웨어에서 사용을 못하는 것이다. 게다가 32비트 윈도우용 애플리케이션은 구조적으로 각 프로그램 당 총 2GB까지만 이용할 수 있게 되어 있었다.

사실 4GB 문제를 예견 못 한 것은 아니라서 [[인텔 펜티엄 프로|펜티엄 프로]]에서 PAE(Physical Address Extension: 물리 주소 확장)라는 기술이 도입되었고, 이를 이용하면 주소에 36비트를 이용하여 총 64GB까지 이용할 수 있었다. 하지만 이것은 메인보드에 64GB까지 꽂아서 쓸 수 있다는 것이지 프로그램 내부에서 이용하는 가상 주소는 이전과 마찬가지로 32비트를 이용하므로 각각의 애플리케이션 측면에서는 기존의 구조와 동일한 관계로 2GB까지만 이용 가능하다. 그나마 윈도우 고급 서버에서는 총 메모리를 많이 이용할 수 있지만 윈도우 저급 서버나 클라이언트용 윈도우는 ~~버전별로 차별화를 둬서 비싸게 팔아먹으려는 MS의 농간으로~~ 4GB 제한이 여전하다. MS의 말에 의하면 4GB 이상을 지원했을 때 드라이버가 불안정해지는 사례가 많았다고는 하지만... 어쨌든 클라이언트 윈도우에서도 제한적인 PAE 지원 덕분에 낭비되는 메모리를 [[램디스크]]로 활용할 수는 있으며, 프로세스의 메모리 영역 보호에도 PAE의 기능을 적용하고 있다.

때문에 64비트인 [[AMD x86-64]] 아키텍처에서는 메모리 주소를 32비트에서 48비트로 확 올렸다. 일단 64비트를 통째로 이용하는 것은 효율성이 떨어진다고 본 듯.(이는 페이징 때문으로, 주소 지정을 하는 비트 수 만큼 필요한 페이지 테이블의 용량은 늘어나기 때문이다.) 하지만 48비트로도 256TB까지 지원하는데 현재 CPU 하나당 메모리를 아무리 많아봤자 수백기가 정도 이용하는 것을 보면 당분간은 충분할 듯 하다. 게다가 나중에 더 확장할 수도 있어서, 64비트를 모두 이용하면 16[[엑사|E]]B까지 지원하는데 이를 다시 쓰면 1800[[큰 수|경]]바이트이다. 과연 이게 부족한 일이 있을지 모르겠다. 물론 미래에는 어떻게 될지야 모르기는 하지만.

어쨌거나 4GB를 넘는 메모리를 사용하려면 하드웨어와 소프트웨어 둘 다 64비트를 지원해야 한다. 하드웨어 쪽은 이미 64비트를 지원하고 있는데[* 컴퓨터 부품은 싫어도 CPU와 아키텍처를 맞춰야 하고 CPU벤더는 일찌감치 64비트로 갈아탔다. [[AMD x86-64]] 지원 CPU가 AMD는 2003년([[AMD 옵테론 시리즈|애슬론 64/옵테론]]), 인텔은 2004년(펜티엄4 프레스캇 - 초기 모델은 제외)부터 나오기 시작했다] 소프트웨어쪽이 대응이 늦어 이런 장벽이 만들어졌다. 특히 클라이언트용 윈도우는 2010년대 초반까지만 해도 32비트가 여전히 많이 쓰였다. 운영체제가 지원해도 애플리케이션이 64비트를 지원하지 않으면 이전과 마찬가지로 2GB밖에 못 쓴다.

[윈도우 비스타]부터는 [[윈도 XP]]와 달리 아예 64비트 버전을 동봉해 놓았다.[* 단 DSP 버전은 비트별로 나누어져 있다.] 응용프로그램의 메모리 요구량은 세월이 갈수록 높아지기만 하므로 32비트 OS는 몇 년 내로 자취를 감추게 될 것이다.[* 실제로 서버용 Windows의 경우 Server 2008 이후 32비트 버전을 출시하지 않고 있다. Red hat의 RHEL도 Version 7 부터는 64비트 버전만 나온다] ~~근데 아무래도 [윈도우 10]까지 32비트가 있는 걸로 보아 아직 좀 더 있어야 할 것 같다.~~ ~~뭐 어차피 [[2038년 문제|2038년]]이 되면 다 없어질 거지만~~

참고로 64비트로 나타낼 수 있는 숫자는 0~18,446,744,073,709,551,615 까지(18EB, 16EiB)이다. 역시 OS에 따라 다르지만 64비트 [리눅스]의 경우 사용자 공간으로 8 EB까지 쓸 수 있다.

== ~~18EB 문제~~ ==
물론 취소선이 그어질 정도로 많은 용량이긴 하지만, 결국 근본적인 문제가 해결되지 않는 한 언젠간 다가올 문제이다.
과거와 같은 개발속도(1.5년마다 2배) 가 이어진다면,--공돌이를 계속 갈아 넣는다면-- 가정용 컴퓨터에는 2070년쯤(...) 생길 문제다. 
--2060년쯤에 취소선이 지워지겠군--
~~물론 그때까지 위키가 남아있으면 말이지~~
