[[목차]]

正規表現式, Regular expression. 정규식이라고도 부른다. 보통 regex 혹은 regexp 라 많이 쓴다. 

== 개요 ==

[[프로그래밍]]에서 사용하는 일종의 형식 언어. 주로 문자열(string) 관련 프로그래밍에 많이 사용된다. 프로그램을 작성할 때는 특성상 일정한 규칙을 가진 텍스트 문자열을 사용하는 경우가 많은데, 이럴 때 정규 표현식을 사용한다. 유닉스 계열 운영체제에서 CLI 환경을 주로 사용하는 경우 grep, sed, awk 등으로 인해 거의 필수적으로 알게될수밖에 없는 언어.(모르고 CLI 환경에서 컴퓨터를 사용할수도 있긴 하지만, 그럴경우 그냥 GUI 환경을 사용하는것에 비해 노가다가 현저하게 늘어나고 생산성이 매우 떨어진다.) 

잘 알아두면 문자열을 다루는 데 대단히 유용하기 때문에 C를 비롯한 여러 프로그래밍 언어에서 이 정규 표현식을 지원한다. 특히 웹 프로그래밍은 문자열을 다루는 빈도가 특히 높기 때문에 사용하는게 거의 필수적. 예를 들면 [[위키위키]]만 해도 DB에 저장된 텍스트에 있는 위키 문법을 엔진에서 해석해서 출력해 주는 작업이 필요한데, 위키 문법도 일정한 규칙이 있는 문자열인 만큼 이 작업에서 정규표현식은 반드시 들어간다. 

정규 표현식은 언어마다 문법이 조금씩 다른데, 쉘에서 주로 정규표현식을 사용하는 사용자 입장에서는 이것이 문제가 되는경우도 종종 있다. 크게 나누면 표준으로 인정된 POSIX의 정규 표현식과 그것에서 문법을 매우 확장한 [[wiki:"펄(프로그래밍 언어)" Perl]] 방식의 [[http://www.pcre.org/ PCRE]][* Perl Compatible Regular Expressions. 이름에서 보이듯이 Perl 호환 정규표현식이지만 완전한 호환은 아니다. ] 이 둘로 나뉘어지며, POSIX 표준의 경우 다시 Basic 과 Extended 로 나뉜다. 이외에도 Emacs 와 Vim 모두 자체적인 정규표현식을 지원한다. 문제는, 이 정규표현식들이 완전히 다르면 모르겠지만, 비슷하면서도 살짝살짝 다르기때문에 그 차이들을 다 외우고 있을수도 없는 노릇이며, 정규표현식 자체가 다량의 텍스트를 다루는 명령인만큼 작은 실수가 커다란 차이를 불러올 수 있다는점이다. 즉, 쉘에서 쓰기 작업에 정규표현식을 동반할경우 매우 주의를 요할 필요가 있다. 또다른 문제는, 자신이 뭘 원한다고 해서 그것만 배우고 쓰면 되는게 아니라 프로그램마다 지원하는 정규표현식이 다르기때문에 그에 맞춰 배우고 써줘야 한다.[* 물론, 오늘날에는 전부는 아니더라도 다른 정규표현식에 대응되는 명령들도 기본으로 포함하고 있는 유닉스나 리눅스 배포판들이 많다. 예를들어, grep 대신 Extended 정규표현식을 사용하는 egrep, sed 대신 PCRE 정규표현식을 사용하는 psed 등이 그것이다. ] PCRE의 경우 이미 정규표현식이라고 부를 수 없을 정도로 기능이 확장되어 있는데[* 원래 정규표현식은 [[노엄 촘스키]]가 만든 촘스키 위계 3유형에 속하는 [[wiki:"형식 문법" 정규 문법]]에 대응되는데, PCRE에는 정규 문법에서 허용되지 않는 역참조(이전에 매칭된 부분문자열과 같은 패턴을 다시 매칭)와 같은 기능을 추가로 제공한다. ], 덕분에 [[http://www.catonmat.net/blog/perl-regex-that-matches-prime-numbers/ 이런 이상한 짓]]도 가능하다. (...)

정규식은 아래와 같은 기본문법으로 구성되어있다.

 * {{{^}}} : 문자열의 시작
 * {{{$}}} : 문자열의 종료
 * {{{.}}} : 임의의 한 문자
 * {{{|}}} : or를 나타냄
 * {{{?}}} : 앞 문자가 없거나 하나있음
 * {{{+}}} : 앞 문자가 하나 이상임
 * {{{*}}} : 앞 문자가 없을 수도 무한정 많을 수도 있음
 * {{{ {n,m} }}} : 앞 문자가 {{{n}}}개 이상 {{{m}}}개 이하. {{{ {0,1} }}}은 {{{?}}}와 같은 의미다.
 * {{{ {n,} }}} : 앞 문자가 {{{n}}}개 이상. 위의 형태에서 {{{m}}}이 생략된 형태이다. {{{ {0,} }}}이면 {{{*}}}와 같고 {{{ {1,} }}}이면 {{{+}}}와 같은 의미이다.

기본적인 정규식
 * {{{^[0-9]*$}}}  :  숫자
 * {{{^[a-zA-Z]*$}}}  :  영문자
 * {{{^[가-힣]*$}}}  :  한글
 * {{{^[a-zA-Z0-9]*$}}}  :  영어/숫자

정규표현식에서는 일치하는 패턴을 찾는 횟수제한이 없어 필요이상의 상황을 연출하기도 하는데 이것은 의도적으로 수량자를 탐욕적으로 만들었기 때문이다. 문법에서 말하는 탐욕적 수량자란 가능하면 가장 큰 덩어리를 찾는다는 뜻이며, 반대의 개념인 게으른 수량자(Lazy Quantifier)는 패턴에 근접하는 최소한의 덩어리를 찾는다.

 * 탐욕적 수량자 : {{{*}}}, {{{+}}}, {{{ {n,} }}}
 * 게으른 수량자 : {{{*?}}}, {{{+?}}}, {{{ {n,}? }}}

사용 예([[wiki:"파이썬" Python]]) :
{{{
>>> data = "<div> <p>First</p> <p>Second</p></div>"
>>> import re
>>> re.findall(r"<p>(.+)</p>", data)  # 기본적으로 탐욕적인 매칭
['First</p> <p>Second']
>>> re.findall(r"<p>(.+?)</p>", data)  # 게으른 수량자 사용
['First', 'Second']
}}}
